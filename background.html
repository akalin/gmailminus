<html>
<head>
<script>
var animationFrames = 36;
var animationSpeed = 10; // ms
var canvas;
var canvasContext;
var loggedInImage;
var pollIntervalMin = 1000 * 60;  // 1 minute
var pollIntervalMax = 1000 * 60 * 60;  // 1 hour
var requestFailureCounts = [];  // used for exponential backoff
var requestTimeout = 1000 * 2;  // 5 seconds
var rotation = 0;
var unreadCounts = [];
var loadingAnimation = new LoadingAnimation();

function getGmailUrl(index) {
  var url = "https://mail.google.com/mail/u/" + index + "/";
  return url;
}

function getFeedUrl(index) {
  return getGmailUrl(index) + "feed/atom";
}

function getGmailUrlIndex(url) {
  var match = /^https:\/\/mail.google.com\/mail\/u\/([012])/.exec(url);
  return match ? match[1] : -1;
}

// A "loading" animation displayed while we wait for the first response from
// Gmail. This animates the badge text with a dot that cycles from left to
// right.
function LoadingAnimation() {
  this.timerId_ = 0;
  this.maxCount_ = 8;  // Total number of states in animation
  this.current_ = 0;  // Current state
  this.maxDot_ = 4;  // Max number of dots in animation
}

LoadingAnimation.prototype.paintFrame = function() {
  var text = "";
  for (var i = 0; i < this.maxDot_; i++) {
    text += (i == this.current_) ? "." : " ";
  }
  if (this.current_ >= this.maxDot_)
    text += "";

  chrome.browserAction.setBadgeText({text:text});
  this.current_++;
  if (this.current_ == this.maxCount_)
    this.current_ = 0;
}

LoadingAnimation.prototype.start = function() {
  if (this.timerId_)
    return;

  var self = this;
  this.timerId_ = window.setInterval(function() {
    self.paintFrame();
  }, 100);
}

LoadingAnimation.prototype.stop = function() {
  if (!this.timerId_)
    return;

  window.clearInterval(this.timerId_);
  this.timerId_ = 0;
}


chrome.tabs.onUpdated.addListener(function(tabId, changeInfo) {
  if (changeInfo.url) {
    index = getGmailUrlIndex(changeInfo.url);
    if (index != -1) {
      console.info("Detected tab for inbox " + index);
      getInboxCount(index, function(email, count) {
        updateUnreadCount(index, email, count);
      });
    }
  }
});


function init() {
  canvas = document.getElementById('canvas');
  loggedInImage = document.getElementById('logged_in');
  canvasContext = canvas.getContext('2d');

  chrome.browserAction.setBadgeBackgroundColor({color:[208, 0, 24, 255]});
  chrome.browserAction.setIcon({path: "gmail_logged_in.png"});
  loadingAnimation.start();

  for (i = 0; i < 3; ++i) {
    startRequest(i);
  }
}

function scheduleRequest(index) {
  var randomness = Math.random() * 2;
  requestFailureCount = requestFailureCounts[index] || 0;
  console.info("requestFailureCount = " + requestFailureCount);
  var exponent = Math.pow(2, requestFailureCount);
  var delay = Math.min(randomness * pollIntervalMin * exponent,
                       pollIntervalMax);
  delay = Math.round(delay);

  console.info("scheduling request for inbox " + index +
	       " at " + delay + " ms");
  window.setTimeout(function() { startRequest(index); }, delay);
}

// ajax stuff
function startRequest(index) {
  console.info("starting request for inbox " + index);
  getInboxCount(index, 
    function(email, count) {
      console.info("request for inbox " + index + " succeeded with " +
		   email + " and " + count);
      loadingAnimation.stop();
      updateUnreadCount(index, email, count);
      scheduleRequest(index);
    },
    function() {
      console.info("request for inbox " + index + " failed");
      loadingAnimation.stop();
      scheduleRequest(index);
    }
  );
}

function getInboxCount(index, onSuccess, onError) {
  var xhr = new XMLHttpRequest();
  var abortTimerId = window.setTimeout(function() {
    xhr.abort();  // synchronously calls onreadystatechange
  }, requestTimeout);

  function handleSuccess(email, count) {
    requestFailureCounts[index] = 0;
    window.clearTimeout(abortTimerId);
    if (onSuccess)
      onSuccess(email, count);
  }

  function handleError() {
    requestFailureCounts[index] = requestFailureCounts[index] || 0;
    ++requestFailureCounts[index];
    window.clearTimeout(abortTimerId);
    if (onError)
      onError();
  }

  try {
    xhr.onreadystatechange = function(){
      if (xhr.readyState != 4)
        return;

      var success = false;
      var email, fullCount;
      if (xhr.responseXML) {
        success = true;
        var xmlDoc = xhr.responseXML;
        var titleSet = xmlDoc.evaluate("/gmail:feed/gmail:title",
            xmlDoc, gmailNSResolver, XPathResult.ANY_TYPE, null);
        var titleNode = titleSet.iterateNext();
        if (titleNode) {
          title = titleNode.textContent;
          var match = /^Gmail - Inbox for (\S+)$/.exec(title);
          email = match[1];
        } else {
          success = false;
        }

        var fullCountSet = xmlDoc.evaluate("/gmail:feed/gmail:fullcount",
            xmlDoc, gmailNSResolver, XPathResult.ANY_TYPE, null);
        var fullCountNode = fullCountSet.iterateNext();
        if (fullCountNode) {
          fullCount = fullCountNode.textContent;
        } else {
          success = false;
        }
      }

      if (success) {
        handleSuccess(email, fullCount);
      } else {
        console.error(chrome.i18n.getMessage("gmailcheck_node_error"));
        handleError();
      }
    }

    xhr.onerror = function(error) {
      handleError();
    }

    xhr.open("GET", getFeedUrl(index), true);
    xhr.send(null);
  } catch(e) {
    console.error(chrome.i18n.getMessage("gmailcheck_exception", e));
    handleError();
  }
}

function gmailNSResolver(prefix) {
  if(prefix == 'gmail') {
    return 'http://purl.org/atom/ns#';
  }
}

function updateUnreadCount(index, email, count) {
  if (unreadCounts[index] && unreadCounts[index].count != count) {
    console.info("Updating inbox " + index + ": " + email + ", " + count);
    unreadCounts[index].email = email;
    unreadCounts[index].count = count;
    animateFlip();
  }
}


function ease(x) {
  return (1-Math.sin(Math.PI/2+x*Math.PI))/2;
}

function animateFlip() {
  rotation += 1/animationFrames;
  drawIconAtRotation();

  if (rotation <= 1) {
    setTimeout("animateFlip()", animationSpeed);
  } else {
    rotation = 0;
    drawIconAtRotation();
    unreadCountText = "";
    for (i in unreadCounts) {
      unreadCountText = unreadCounts[i].count + ",";
    }
    chrome.browserAction.setBadgeText({
      text: unreadCountText
    });
    chrome.browserAction.setBadgeBackgroundColor({color:[208, 0, 24, 255]});
  }
}

function drawIconAtRotation() {
  canvasContext.save();
  canvasContext.clearRect(0, 0, canvas.width, canvas.height);
  canvasContext.translate(
      Math.ceil(canvas.width/2),
      Math.ceil(canvas.height/2));
  canvasContext.rotate(2*Math.PI*ease(rotation));
  canvasContext.drawImage(loggedInImage,
      -Math.ceil(canvas.width/2),
      -Math.ceil(canvas.height/2));
  canvasContext.restore();

  chrome.browserAction.setIcon({imageData:canvasContext.getImageData(0, 0,
      canvas.width,canvas.height)});
}

function goToInbox() {
  chrome.tabs.getAllInWindow(undefined, function(tabs) {
    for (var i = 0, tab; tab = tabs[i]; i++) {
      if (tab.url) {
        index = getGmailUrlIndex(tab.url);
        console.info("Going to inbox " + index);
        if (index != -1) {
          chrome.tabs.update(tab.id, {selected: true});
          return;
        }
      }
    }
    console.info("Going to default inbox");
    chrome.tabs.create({url: getGmailUrl(0)});
  });
}

// Called when the user clicks on the browser action.
chrome.browserAction.onClicked.addListener(function(tab) {
  goToInbox();
});

</script>
</head>
<body onload="init()">
<img id="logged_in" src="gmail_logged_in.png">
<canvas id="canvas" width="19" height="19">
</body>
</html>

